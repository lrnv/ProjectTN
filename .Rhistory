S <- S0 * cumprod(1+r * delta_t + sigma * sqrt(delta_t) * alea)
# Probabilité de franchissement du seuil :
p_k <- function(x,y){
return(exp(-2*log(x/Sa)*log(y/Sa)/(sigma^2)*delta_t))
}
p <- S^0
for (i in 1:length(p)){
if(i==1){p[i] = 1}
else{
p[i] <- p_k(S[i],S[i-1])
}
}
p <- p_k(c(NA,S),c(S,NA))[2:(length(S)-1)]
p
p <- p_k(c(NA,S),c(S,NA))[2:(length(S)-1)]
p
p <- c(1,p_k(c(NA,S),c(S,NA))[1:(length(S)-1)])
p
p <- c(1,(p_k(c(NA,S),c(S,NA))[1:(length(S)-1)]))
p
p <- c(1,(p_k(c(NA,S),c(S,NA))[2:(length(S)-1)]))
p
for (i in 1:length(p)){
if(i==1){p[i] = 1}
else{
p[i] <- p_k(S[i],S[i-1])
}
}
p
#
# p <- S^0
#
p <- c(1,(p_k(c(NA,S),c(S,NA))[2:(length(S)-1)])) > runif(1/delta_t)
c(1,(p_k(c(NA,S),c(S,NA))[2:(length(S)-1)]))
c(1,(p_k(c(NA,S),c(S,NA))[2:(length(S)-1)])) %>% length
#
# p <- S^0
#
p <- c(1,(p_k(c(NA,S),c(S,NA))[2:(length(S)-1)])) > runif((1/delta_t)-1)
p
p
#
# p <- S^0
#
p <- c(1,(p_k(c(NA,S),c(S,NA))[2:(length(S)-1)]))
p
S
plot(S)
alea <- rnorm(1/delta_t)
S <- S0 * cumprod(1+r * delta_t + sigma * sqrt(delta_t) * alea)
S %>% plot
#
# p <- S^0
#
p <- c(1,(p_k(c(NA,S),c(S,NA))[2:(length(S)-1)]))
p
sigma
sigma = 0.45
alea <- rnorm(1/delta_t)
S <- S0 * cumprod(1+r * delta_t + sigma * sqrt(delta_t) * alea)
S
plot(S)
# Probabilité de franchissement du seuil :
p_k <- function(x,y){
return(exp(-2*log(x/Sa)*log(y/Sa)/(sigma^2)*delta_t))
}
#
# p <- S^0
#
p <- c(1,(p_k(c(NA,S),c(S,NA))[2:(length(S)-1)]))
p
sigma = 0.01
alea <- rnorm(1/delta_t)
S <- S0 * cumprod(1+r * delta_t + sigma * sqrt(delta_t) * alea)
# Probabilité de franchissement du seuil :
p_k <- function(x,y){
return(exp(-2*log(x/Sa)*log(y/Sa)/(sigma^2)*delta_t))
}
#
# p <- S^0
#
p <- c(1,(p_k(c(NA,S),c(S,NA))[2:(length(S)-1)]))
plot(S)
p
rPDD_raffi <- function(S0=100,Sa=120,delta_t = 1/20,alpha=0.2,r=0.015,sigma=0.45,rafinement=TRUE){
alea <- rnorm(1/delta_t)
S <- S0 * cumprod(1+r * delta_t + sigma * sqrt(delta_t) * alea)
# Probabilité de franchissement du seuil :
p_k <- function(x,y){
return(exp(-2*log(x/Sa)*log(y/Sa)/(sigma^2)*delta_t))
}
p <- c(1,(p_k(c(NA,S),c(S,NA))[2:(length(S)-1)]))
p <- p > runif((1/delta_t)-1)
# Approximation du sup sur 6mois :
sup_6_mois <- max(S[(floor(length(S)/2)+1):length(S)])
# Clacul de la PDD :
return(prod(p)*max(Sa-S[length(S)],0) * (S[length(S)] < (1-alpha) * Sa) * (sup_6_mois < Sa))
}
M = 10000
PDD_0 <- rep(NA,M) %>%
sapply(.,function(x) {
return(rPDD_raffi())
}) %T>%
{print(mean(.))}
PDD_0 <- rep(NA,M) %>%
sapply(.,function(x) {
return(rPDD_raffi())
}) %T>%
{print(mean(.))}
PDD_0 <- rep(NA,M) %>%
sapply(.,function(x) {
return(rPDD_raffi())
}) %T>%
{print(mean(.))}
PDD_0 <- rep(NA,M) %>%
sapply(.,function(x) {
return(rPDD_raffi())
}) %T>%
{print(mean(.))}
# Appliquons le rafinement par pont brownien :
rPDD_raffi <- function(S0=100,Sa=120,delta_t = 1/200,alpha=0.2,r=0.015,sigma=0.45,rafinement=TRUE){
alea <- rnorm(1/delta_t)
S <- S0 * cumprod(1+r * delta_t + sigma * sqrt(delta_t) * alea)
# Probabilité de franchissement du seuil :
p_k <- function(x,y){
return(exp(-2*log(x/Sa)*log(y/Sa)/(sigma^2)*delta_t))
}
p <- c(1,(p_k(c(NA,S),c(S,NA))[2:(length(S)-1)]))
p <- p > runif((1/delta_t)-1)
# Maintenant qu'on a la trajectoire de S, calculons la PDD_0 correspondante :
# Approximation du sup sur 6mois :
sup_6_mois <- max(S[(floor(length(S)/2)+1):length(S)])
# Clacul de la PDD :
lambda <-prod(p)*max(Sa-S[length(S)],0) * (S[length(S)] < (1-alpha) * Sa) * (sup_6_mois < Sa)
return(lambda)
}
M = 10000
PDD_0 <- rep(NA,M) %>%
sapply(.,function(x) {
return(rPDD_raffi())
}) %T>%
{print(mean(.))}
PDD_0 <- rep(NA,M) %>%
sapply(.,function(x) {
return(rPDD_raffi())
}) %T>%
{print(mean(.))}
# Appliquons le rafinement par pont brownien :
rPDD_raffi <- function(S0=100,Sa=120,delta_t = 1/2000,alpha=0.2,r=0.015,sigma=0.45,rafinement=TRUE){
alea <- rnorm(1/delta_t)
S <- S0 * cumprod(1+r * delta_t + sigma * sqrt(delta_t) * alea)
# Probabilité de franchissement du seuil :
p_k <- function(x,y){
return(exp(-2*log(x/Sa)*log(y/Sa)/(sigma^2)*delta_t))
}
p <- c(1,(p_k(c(NA,S),c(S,NA))[2:(length(S)-1)]))
p <- p > runif((1/delta_t)-1)
# Maintenant qu'on a la trajectoire de S, calculons la PDD_0 correspondante :
# Approximation du sup sur 6mois :
sup_6_mois <- max(S[(floor(length(S)/2)+1):length(S)])
# Clacul de la PDD :
lambda <-prod(p)*max(Sa-S[length(S)],0) * (S[length(S)] < (1-alpha) * Sa) * (sup_6_mois < Sa)
return(lambda)
}
M = 10000
PDD_0 <- rep(NA,M) %>%
sapply(.,function(x) {
return(rPDD_raffi())
}) %T>%
{print(mean(.))}
rafinement=FALSE
to_sapply <- if(raffinement){
function(x){
return(rPDD_unitaire_rafi())
}
} else {
function(x){
return(rPDD_unitaire_naif())
}
}
raffinement=FALSE
to_sapply <- if(raffinement){
function(x){
return(rPDD_unitaire_rafi())
}
} else {
function(x){
return(rPDD_unitaire_naif())
}
}
to_sapply()
rPDD_unitaire_naif <- function(){
# Commençons par calculer la trajectoire de S :
# S suit une dynamique de black-sholes, donc la solution explicite de BS nous donne :
alea <- rnorm(1/delta_t)
S <- S0 * cumprod(1+r * delta_t + sigma * sqrt(delta_t) * alea)
# Maintenant qu'on a la trajectoire de S, calculons la PDD_0 correspondante :
# Approximation du sup sur 6mois :
sup_6_mois <- max(S[(floor(length(S)/2)+1):length(S)])
# Clacul de la PDD :
lambda <-max(Sa-S[length(S)],0) * (S[length(S)] < (1-alpha) * Sa) * (sup_6_mois < Sa)
return(lambda)
}
rPDD_unitaire_rafi <- function(){
alea <- rnorm(1/delta_t)
S <- S0 * cumprod(1+r * delta_t + sigma * sqrt(delta_t) * alea)
# Probabilité de franchissement du seuil :
p_k <- function(x,y){
return(exp(-2*log(x/Sa)*log(y/Sa)/(sigma^2)*delta_t))
}
p <- c(1,(p_k(c(NA,S),c(S,NA))[2:(length(S)-1)]))
p <- p > runif((1/delta_t)-1)
# Maintenant qu'on a la trajectoire de S, calculons la PDD_0 correspondante :
# Approximation du sup sur 6mois :
sup_6_mois <- max(S[(floor(length(S)/2)+1):length(S)])
# Clacul de la PDD :
lambda <-prod(p)*max(Sa-S[length(S)],0) * (S[length(S)] < (1-alpha) * Sa) * (sup_6_mois < Sa)
return(lambda)
}
to_sapply <- if(raffinement){
function(x){
return(rPDD_unitaire_rafi())
}
} else {
function(x){
return(rPDD_unitaire_naif())
}
}
to_sapply()
to_sapply
to_sapply(1)
to_sapply(10)
to_sapply(10) %>% class
to_sapply %>% class
rPDD <- function(n=1,S0=100,Sa=120,delta_t = 1/200,alpha=0.2,r=0.015,sigma=0.45,raffinement=FALSE){
rPDD_unitaire_naif <- function(){
# Commençons par calculer la trajectoire de S :
# S suit une dynamique de black-sholes, donc la solution explicite de BS nous donne :
alea <- rnorm(1/delta_t)
S <- S0 * cumprod(1+r * delta_t + sigma * sqrt(delta_t) * alea)
# Maintenant qu'on a la trajectoire de S, calculons la PDD_0 correspondante :
# Approximation du sup sur 6mois :
sup_6_mois <- max(S[(floor(length(S)/2)+1):length(S)])
# Clacul de la PDD :
lambda <-max(Sa-S[length(S)],0) * (S[length(S)] < (1-alpha) * Sa) * (sup_6_mois < Sa)
return(lambda)
}
rPDD_unitaire_rafi <- function(){
alea <- rnorm(1/delta_t)
S <- S0 * cumprod(1+r * delta_t + sigma * sqrt(delta_t) * alea)
# Probabilité de franchissement du seuil :
p_k <- function(x,y){
return(exp(-2*log(x/Sa)*log(y/Sa)/(sigma^2)*delta_t))
}
p <- c(1,(p_k(c(NA,S),c(S,NA))[2:(length(S)-1)]))
p <- p > runif((1/delta_t)-1)
# Maintenant qu'on a la trajectoire de S, calculons la PDD_0 correspondante :
# Approximation du sup sur 6mois :
sup_6_mois <- max(S[(floor(length(S)/2)+1):length(S)])
# Clacul de la PDD :
lambda <-prod(p)*max(Sa-S[length(S)],0) * (S[length(S)] < (1-alpha) * Sa) * (sup_6_mois < Sa)
return(lambda)
}
# On retourne le résultat :
if(raffinement){to_sapply <- function(x){return(rPDD_unitaire_rafi())}}
else           {to_sapply <- function(x){return(rPDD_unitaire_naif())}}
return(rep(NA,n) %>% sapply(.,to_sapply))
}
# Petite fonction d'affichage :
affichage <- . %>%
{data.frame(Moyenne = mean(.),ProbaPositif = mean(. > 0))} %>%
{print(.)}
# Test : ( devrais retourner 23/24/25)
rPDD(M) %>% affichage
rPDD(M,raffinement=TRUE) %>% affichage
rPDD <- function(n=1,S0=100,Sa=120,delta_t = 1/200,alpha=0.2,r=0.015,sigma=0.45,raffinement=FALSE){
# Probabilité de franchissement du seuil dans le cas de pont brownien :
p_k <- function(x,y){
return(exp(-2*log(x/Sa)*log(y/Sa)/(sigma^2)*delta_t))
}
# Calcul d'une PDD :
rPDD_unitaire_naif <- function(naif = !raffinement){
# Commençons par calculer la trajectoire de S :
# S suit une dynamique de black-sholes, donc la solution explicite de BS nous donne :
alea <- rnorm(1/delta_t)
S <- S0 * cumprod(1+r * delta_t + sigma * sqrt(delta_t) * alea)
# Gestion du raffinement par pont brownien :
p = S^0
if(!naif){
p <- c(1,(p_k(c(NA,S),c(S,NA))[2:(length(S)-1)]))
p <- p > runif((1/delta_t)-1)
}
# Maintenant qu'on a la trajectoire de S, calculons la PDD_0 correspondante :
# Approximation du sup sur 6mois :
sup_6_mois <- max(S[(floor(length(S)/2)+1):length(S)])
# Calcul final de la PDD :
lambda <-prod(p)*max(Sa-S[length(S)],0) * (S[length(S)] < (1-alpha) * Sa) * (sup_6_mois < Sa)
return(lambda)
}
# On retourne le résultat :
to_sapply <- function(x){return(rPDD_unitaire(naif=!raffinement))}}
return(rep(NA,n) %>% sapply(.,to_sapply))
}
rPDD <- function(n=1,S0=100,Sa=120,delta_t = 1/200,alpha=0.2,r=0.015,sigma=0.45,raffinement=FALSE){
# Probabilité de franchissement du seuil dans le cas de pont brownien :
p_k <- function(x,y){
return(exp(-2*log(x/Sa)*log(y/Sa)/(sigma^2)*delta_t))
}
# Calcul d'une PDD :
rPDD_unitaire_naif <- function(naif = !raffinement){
# Commençons par calculer la trajectoire de S :
# S suit une dynamique de black-sholes, donc la solution explicite de BS nous donne :
alea <- rnorm(1/delta_t)
S <- S0 * cumprod(1+r * delta_t + sigma * sqrt(delta_t) * alea)
# Gestion du raffinement par pont brownien :
p = S^0
if(!naif){
p <- c(1,(p_k(c(NA,S),c(S,NA))[2:(length(S)-1)]))
p <- p > runif((1/delta_t)-1)
}
# Maintenant qu'on a la trajectoire de S, calculons la PDD_0 correspondante :
# Approximation du sup sur 6mois :
sup_6_mois <- max(S[(floor(length(S)/2)+1):length(S)])
# Calcul final de la PDD :
lambda <-prod(p)*max(Sa-S[length(S)],0) * (S[length(S)] < (1-alpha) * Sa) * (sup_6_mois < Sa)
return(lambda)
}
# On retourne le résultat :
to_sapply <- function(x){return(rPDD_unitaire(naif=!raffinement))}}
return(rep(NA,n) %>% sapply(.,to_sapply))
}
rPDD <- function(n=1,S0=100,Sa=120,delta_t = 1/200,alpha=0.2,r=0.015,sigma=0.45,raffinement=FALSE){
# Probabilité de franchissement du seuil dans le cas de pont brownien :
p_k <- function(x,y){
return(exp(-2*log(x/Sa)*log(y/Sa)/(sigma^2)*delta_t))
}
# Calcul d'une PDD :
rPDD_unitaire_naif <- function(naif = !raffinement){
# Commençons par calculer la trajectoire de S :
# S suit une dynamique de black-sholes, donc la solution explicite de BS nous donne :
alea <- rnorm(1/delta_t)
S <- S0 * cumprod(1+r * delta_t + sigma * sqrt(delta_t) * alea)
# Gestion du raffinement par pont brownien :
p = S^0
if(!naif){
p <- c(1,(p_k(c(NA,S),c(S,NA))[2:(length(S)-1)]))
p <- p > runif((1/delta_t)-1)
}
# Maintenant qu'on a la trajectoire de S, calculons la PDD_0 correspondante :
# Approximation du sup sur 6mois :
sup_6_mois <- max(S[(floor(length(S)/2)+1):length(S)])
# Calcul final de la PDD :
lambda <-prod(p)*max(Sa-S[length(S)],0) * (S[length(S)] < (1-alpha) * Sa) * (sup_6_mois < Sa)
return(lambda)
}
# On retourne le résultat :
return(rep(NA,n) %>%
sapply(.,function(x){
return(rPDD_unitaire(naif=!raffinement))
}
))
}
# Petite fonction d'affichage :
affichage <- . %>%
{data.frame(Moyenne = mean(.),ProbaPositif = mean(. > 0))} %>%
{print(.)}
# Test : ( devrais retourner 23/24/25)
rPDD(M) %>% affichage
# Fonction de simulation de PDD.
rPDD <- function(n=1,S0=100,Sa=120,delta_t = 1/200,alpha=0.2,r=0.015,sigma=0.45,raffinement=FALSE){
# Probabilité de franchissement du seuil dans le cas de pont brownien :
p_k <- function(x,y){
return(exp(-2*log(x/Sa)*log(y/Sa)/(sigma^2)*delta_t))
}
# Calcul d'une PDD :
rPDD_unitaire <- function(naif = !raffinement){
# Commençons par calculer la trajectoire de S :
# S suit une dynamique de black-sholes, donc la solution explicite de BS nous donne :
alea <- rnorm(1/delta_t)
S <- S0 * cumprod(1+r * delta_t + sigma * sqrt(delta_t) * alea)
# Gestion du raffinement par pont brownien :
p = S^0
if(!naif){
p <- c(1,(p_k(c(NA,S),c(S,NA))[2:(length(S)-1)]))
p <- p > runif((1/delta_t)-1)
}
# Maintenant qu'on a la trajectoire de S, calculons la PDD_0 correspondante :
# Approximation du sup sur 6mois :
sup_6_mois <- max(S[(floor(length(S)/2)+1):length(S)])
# Calcul final de la PDD :
lambda <-prod(p)*max(Sa-S[length(S)],0) * (S[length(S)] < (1-alpha) * Sa) * (sup_6_mois < Sa)
return(lambda)
}
# On retourne le résultat :
return(rep(NA,n) %>%
sapply(.,function(x){
return(rPDD_unitaire(naif=!raffinement))
}
))
}
# Petite fonction d'affichage :
affichage <- . %>%
{data.frame(Moyenne = mean(.),ProbaPositif = mean(. > 0))} %>%
{print(.)}
# Test : ( devrais retourner 23/24/25)
rPDD(M) %>% affichage
#1.1.2 Méthode par pont brownien :
rPDD(M,raffinement=TRUE) %>% affichage
PDDRaffinee<-function(r,sigma,T,alpha){
J=365
N=100
dt=T/J
Simu<-matrix(0,N,J*T+1)
Simu[,1]=S0
for(i in 1:N){
for (k in 2:(J*T+1))
{
Simu[i,k]<-Simu[i,k-1]*(1+r*dt+sigma*sqrt(dt)*rnorm(1,0,1))
if (Simu[i,k]<0) Simu[i,k]=0
}
}
PDDanraf<-matrix(0,N,T)
VecSraf<-matrix(0,N,T)
VecSraf[,1]<-Sa
PDDraf<-rep(0,T)
PDDtotraf=0
condition<-matrix(1,N,T*J+1)
probas<-rep(0,N)
for (i in 1:J*T+1){
if(i%%J>(J/2)){
for(j in 1:N){
if (Simu[j,i]>Sa||Simu[j,(i+1)]>Sa) condition[j,i]=0
else{
probas[j]=exp(-2*log((Simu[j,i]/Sa))*(log(Simu[j,(i+1)]/Sa))/(sigma^2*dt))
if(runif(1,0,1)<probas[j]){
condition[j,i]=0
}
}
}
}
}
for (i in 1:N){
if (0%in%condition[i,1:(N+1)]==FALSE){
PDDanraf[i,1]<-(Sa-Simu[i,(J+1)])*(Sa-Simu[i,(J+1)]>0)*((Simu[i,J+1]<(1-alpha)*Sa))*(max(Simu[i,(J/2+1):(J+1)])<Sa)
}
else PDDanraf[i,1]=0
if(T>1){
for (j in 1:(T-1)){
VecSraf[i,(j+1)]<-VecSraf[i,j]-PDDanraf[i,j]
if (0%in%condition[i,(j*J+1):((j+1)*J+1)]==FALSE){
PDDanraf[i,(j+1)]<-(VecSraf[i,(j+1)]-Simu[i,(J*(j+1)+1)])*(VecSraf[i,(j+1)]-Simu[i,(J*(j+1)+1)]>0)*(Simu[i,(J*(j+1)+1)]<(1-alpha)*Sa)*(max(Simu[i,((j+0.5)*J+1):(J*(j+1)+1)])<S0)
}
else PDDanraf[i,(j+1)]=0
}
}
}
for (j in 1:T){
PDDraf[j]=(sum(PDDanraf[,j])/N)
PDDtotraf=PDDtotraf+exp(-r*j)*PDDraf[j]
}
return(PDDtotraf)
}
PDDRaffinee(0.015,0.45,1,0.20)
# Fonction de simulation de PDD.
rPDD <- function(n=1,S0=100,Sa=120,delta_t = 1/365,alpha=0.2,r=0.015,sigma=0.45,raffinement=FALSE){
# Probabilité de franchissement du seuil dans le cas de pont brownien :
p_k <- function(x,y){
return(exp(-2*log(x/Sa)*log(y/Sa)/(sigma^2)*delta_t))
}
# Calcul d'une PDD :
rPDD_unitaire <- function(naif = !raffinement){
# Commençons par calculer la trajectoire de S :
# S suit une dynamique de black-sholes, donc la solution explicite de BS nous donne :
alea <- rnorm(1/delta_t)
S <- S0 * cumprod(1+r * delta_t + sigma * sqrt(delta_t) * alea)
# Gestion du raffinement par pont brownien :
p = S^0
if(!naif){
p <- c(1,(p_k(c(NA,S),c(S,NA))[2:(length(S)-1)]))
p <- p > runif((1/delta_t)-1)
}
# Maintenant qu'on a la trajectoire de S, calculons la PDD_0 correspondante :
# Approximation du sup sur 6mois :
sup_6_mois <- max(S[(floor(length(S)/2)+1):length(S)])
# Calcul final de la PDD :
lambda <-prod(p)*max(Sa-S[length(S)],0) * (S[length(S)] < (1-alpha) * Sa) * (sup_6_mois < Sa)
return(lambda)
}
# On retourne le résultat :
return(rep(NA,n) %>%
sapply(.,function(x){
return(rPDD_unitaire(naif=!raffinement))
}
))
}
# Petite fonction d'affichage :
affichage <- . %>%
{data.frame(Moyenne = mean(.),ProbaPositif = mean(. > 0))} %>%
{print(.)}
# Test : ( devrais retourner 23/24/25)
rPDD(M) %>% affichage
#1.1.2 Méthode par pont brownien :
rPDD(M,raffinement=TRUE) %>% affichage
source('~/work isfa/3A/TechNumProject/Projet.R', encoding = 'UTF-8')
install.packages(magrittr)
install.packages("magrittr")
install.packages("magrittr")
######### Premier script R du projet de technique numérique.
library(magrittr)
######### Premier script R du projet de technique numérique.
library(magrittr)
set.seed(100) # seed
